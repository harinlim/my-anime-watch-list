create type "public"."collaborator_access" as enum ('owner', 'editor', 'viewer');

drop policy "Enable read access for all users" on "public"."watchlists";

drop policy "Enable update for users based on user_id" on "public"."watchlists";

drop policy "Enable delete for users based on user id" on "public"."watchlists_anime";

drop policy "Enable insert for authenticated users only" on "public"."watchlists_anime";

drop policy "Enable read access for all users" on "public"."watchlists_anime";

create table "public"."watchlists_users" (
    "watchlist_id" bigint generated by default as identity not null,
    "user_id" uuid not null default auth.uid(),
    "role" collaborator_access not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."watchlists_users" enable row level security;

alter table "public"."user_reviews" add column "review_text" text;

CREATE UNIQUE INDEX watchlists_users_pkey ON public.watchlists_users USING btree (watchlist_id, user_id);

alter table "public"."watchlists_users" add constraint "watchlists_users_pkey" PRIMARY KEY using index "watchlists_users_pkey";

alter table "public"."watchlists_users" add constraint "watchlists_users_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE not valid;

alter table "public"."watchlists_users" validate constraint "watchlists_users_user_id_fkey";

alter table "public"."watchlists_users" add constraint "watchlists_users_watchlist_id_fkey" FOREIGN KEY (watchlist_id) REFERENCES watchlists(id) ON DELETE CASCADE not valid;

alter table "public"."watchlists_users" validate constraint "watchlists_users_watchlist_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.add_default_owner()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$begin
  insert into public.watchlists_users (watchlist_id, user_id, role)
  values (new.id, new.user_id, 'owner');
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.has_watchlist(_user_id uuid, _watchlist_id bigint)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
SELECT EXISTS (
  SELECT 1
  FROM watchlists_users
  WHERE user_id = _user_id
  AND watchlist_id = _watchlist_id
);
$function$
;

grant delete on table "public"."watchlists_users" to "anon";

grant insert on table "public"."watchlists_users" to "anon";

grant references on table "public"."watchlists_users" to "anon";

grant select on table "public"."watchlists_users" to "anon";

grant trigger on table "public"."watchlists_users" to "anon";

grant truncate on table "public"."watchlists_users" to "anon";

grant update on table "public"."watchlists_users" to "anon";

grant delete on table "public"."watchlists_users" to "authenticated";

grant insert on table "public"."watchlists_users" to "authenticated";

grant references on table "public"."watchlists_users" to "authenticated";

grant select on table "public"."watchlists_users" to "authenticated";

grant trigger on table "public"."watchlists_users" to "authenticated";

grant truncate on table "public"."watchlists_users" to "authenticated";

grant update on table "public"."watchlists_users" to "authenticated";

grant delete on table "public"."watchlists_users" to "service_role";

grant insert on table "public"."watchlists_users" to "service_role";

grant references on table "public"."watchlists_users" to "service_role";

grant select on table "public"."watchlists_users" to "service_role";

grant trigger on table "public"."watchlists_users" to "service_role";

grant truncate on table "public"."watchlists_users" to "service_role";

grant update on table "public"."watchlists_users" to "service_role";

create policy "Enable read access for public watchlists or permitted users"
on "public"."watchlists"
as permissive
for select
to public
using ((is_public OR (( SELECT auth.uid() AS uid) = user_id) OR has_watchlist(( SELECT auth.uid() AS uid), id)));


create policy "Enable update for permitted users"
on "public"."watchlists"
as permissive
for update
to public
using (((( SELECT auth.uid() AS uid) = user_id) OR (( SELECT auth.uid() AS uid) IN ( SELECT watchlists_users.user_id
   FROM watchlists_users
  WHERE ((watchlists_users.watchlist_id = watchlists.id) AND (watchlists_users.user_id = ( SELECT auth.uid() AS uid)) AND (watchlists_users.role = ANY (ARRAY['owner'::collaborator_access, 'editor'::collaborator_access])))))));


create policy "Enable delete for permitted users"
on "public"."watchlists_anime"
as permissive
for delete
to public
using ((watchlist_id IN ( SELECT watchlists.id
   FROM watchlists,
    watchlists_users
  WHERE ((watchlists.user_id = ( SELECT auth.uid() AS uid)) OR ((watchlists_users.watchlist_id = watchlists.id) AND (watchlists_users.user_id = ( SELECT auth.uid() AS uid)) AND (watchlists_users.role = ANY (ARRAY['owner'::collaborator_access, 'editor'::collaborator_access])))))));


create policy "Enable insert for permitted users only"
on "public"."watchlists_anime"
as permissive
for insert
to authenticated
with check ((watchlist_id IN ( SELECT watchlists.id
   FROM watchlists,
    watchlists_users
  WHERE ((watchlists.user_id = ( SELECT auth.uid() AS uid)) OR ((watchlists_users.watchlist_id = watchlists.id) AND (watchlists_users.user_id = ( SELECT auth.uid() AS uid)) AND (watchlists_users.role = ANY (ARRAY['owner'::collaborator_access, 'editor'::collaborator_access])))))));


create policy "Enable read access for all users"
on "public"."watchlists_users"
as permissive
for select
to public
using (has_watchlist(( SELECT auth.uid() AS uid), watchlist_id));


create policy "Enable read access for all users"
on "public"."watchlists_anime"
as permissive
for select
to public
using ((watchlist_id IN ( SELECT watchlists_anime.watchlist_id
   FROM watchlists
  WHERE (watchlists.is_public OR (( SELECT auth.uid() AS uid) = watchlists.user_id) OR (( SELECT auth.uid() AS uid) IN ( SELECT watchlists_users.user_id
           FROM watchlists_users
          WHERE ((watchlists_users.watchlist_id = watchlists.id) AND (watchlists_users.user_id = ( SELECT auth.uid() AS uid)))))))));


CREATE TRIGGER handle_add_default_owner AFTER INSERT ON public.watchlists FOR EACH ROW EXECUTE FUNCTION add_default_owner();


